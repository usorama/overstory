{"type":"decision","title":"Orchestrator Model","rationale":"User Claude Code session IS the orchestrator. No separate daemon. CLAUDE.md + hooks + overstory CLI provides integration. Eliminates extra infrastructure.","classification":"foundational","recorded_at":"2026-02-12T15:18:08.290Z","tags":["orchestrator","claude-code","hooks"],"id":"mx-59ed6a"}
{"type":"decision","title":"Agent Definition: Library Base + Dynamic Overlay","rationale":"Base .md files define HOW (reusable agent role). Dynamic overlay CLAUDE.md defines WHAT (task-specific context). Keeps delegation minimal - team leads only pass WHAT, not HOW.","classification":"foundational","recorded_at":"2026-02-12T15:18:11.173Z","tags":["agents","overlay","delegation"],"id":"mx-396b5a"}
{"type":"decision","title":"Hierarchical Delegation with Depth Limit","rationale":"Orchestrator -> team leads -> specialists. Default max depth 2. Prevents runaway spawning. Leads can call overstory sling to spawn sub-workers. Each level crafts system prompts for agents below.","classification":"foundational","recorded_at":"2026-02-12T15:18:31.165Z","tags":["hierarchy","delegation","depth"],"id":"mx-1ae0ae"}
{"type":"pattern","name":"Layer-by-layer implementation with parallel delegation","description":"Overstory is built in dependency layers (L1 core infra -> L2 agent lifecycle -> L3 merge+orchestration -> L4 watchdog+CLI). Each layer's tasks are independent and can be parallelized across teammates. Close the epic after all subtasks to unblock the next layer. Use beads for tracking: claim all tasks up front, delegate to teammates, close when all pass quality gates.","classification":"tactical","recorded_at":"2026-02-12T15:40:05.248Z","tags":["delegation","parallel","layers"],"id":"mx-2d03ba"}
{"type":"decision","title":"Sessions JSON for agent tracking","rationale":"Simple JSON file avoids another SQLite DB for low-frequency writes. Sling writes new sessions, watchdog/status read them. Worktree clean updates state to zombie.","classification":"tactical","recorded_at":"2026-02-12T15:40:16.433Z","tags":["sessions","state","agents"],"id":"mx-454bf3"}
{"type":"pattern","name":"Worktree-aware config loading","description":"loadConfig resolves the real project root via git rev-parse --git-common-dir when .overstory/config.yaml is not found at cwd. Critical for any overstory command running inside an agent worktree (hooks call log, mail, prime from worktree cwd).","classification":"tactical","recorded_at":"2026-02-12T16:33:29.605Z","id":"mx-1be20d"}
{"type":"decision","title":"CI/CD mirrors mulch project pattern","rationale":"Consistency across jayminwest projects. Separate ci.yml (PRs + push to main, runs lint/typecheck/test) and auto-tag.yml (push to main only, creates git tag + GitHub release on version bump). Uses oven-sh/setup-bun for Bun runtime in GitHub Actions.","classification":"tactical","recorded_at":"2026-02-12T16:33:57.374Z","id":"mx-3fbe85"}
{"type":"pattern","name":"Auto-tag on version bump","description":"auto-tag.yml compares package.json version against existing git tags (not previous commit diff). If no tag exists for the current version, it verifies version sync between package.json and src/index.ts, then creates the tag and a GitHub release with auto-generated notes.","classification":"tactical","recorded_at":"2026-02-12T16:34:00.184Z","id":"mx-2e517a"}
{"type":"convention","content":"Runtime state files in .overstory/ (SQLite DBs, logs, worktrees, sessions.json) must be gitignored. Config files (config.yaml, agent-manifest.json, hooks.json) are committed. Follow .beads/ pattern: put .gitignore inside .overstory/ itself so rules are co-located and self-documenting. overstory init should auto-create this file.","classification":"tactical","recorded_at":"2026-02-12T16:39:57.815Z","id":"mx-c266fc"}
{"type":"pattern","name":"Parallel delegation with shared worktree","description":"When fixing many independent bugs in a single session, spawn Task agents in parallel for groups of related issues. Agents share the same working tree, so coordinate staging carefully — each agent stages its files, but the final git add + commit should be done by the orchestrator after all agents complete. Run quality gates once at the end with all changes combined.","classification":"tactical","recorded_at":"2026-02-12T16:46:26.151Z","id":"mx-c64d33"}
{"type":"convention","content":"Tools that create a dotdir (.overstory/, .beads/) should place their .gitignore inside that directory rather than appending to the project root .gitignore. Patterns are relative to the dotdir. Tracked config files (config.yaml, manifest, hooks) stay tracked; runtime state (DBs, logs, sessions, worktrees) gets ignored.","classification":"tactical","recorded_at":"2026-02-12T16:47:28.327Z","id":"mx-642b5b"}
{"type":"convention","content":"merge-queue.json is a runtime state file in .overstory/ and must be gitignored by init","classification":"tactical","recorded_at":"2026-02-12T17:55:55.586Z","id":"mx-e89cfe"}
{"type":"failure","description":"resolveProjectRoot() checked local .overstory/config.yaml before git worktree detection. Since config.yaml is git-tracked, worktrees have their own copy, causing the function to return the worktree path instead of canonical root. This siloed mail.db and other runtime state per worktree.","resolution":"Reversed check order: git worktree detection runs first. When --git-common-dir resolves to a different root than startDir, we're in a worktree and resolve to the canonical root.","classification":"tactical","recorded_at":"2026-02-12T20:19:07.997Z","id":"mx-130b6c"}
{"type":"decision","title":"E2E validation strategy: dogfood on own repo first","rationale":"Dogfood on overstory's own repo first (where agents/ dir exists at project root), then fix external project support, then test on throwaway project. This avoids blocking on the init deployment fix while proving the core lifecycle works.","classification":"tactical","recorded_at":"2026-02-12T20:58:10.182Z","id":"mx-399754"}
{"type":"failure","description":"Agent definition deployment gap: overstory init creates .overstory/ with config and manifest, but does NOT copy agent definition .md files from overstory's agents/ dir. Config sets agents.baseDir='agents' relative to project root, but those files only exist in overstory's repo. Manifest.load() validates ALL agent .md files exist during sling, causing failure in any external project. Root cause: the implementation plan never specified how target projects access agent definitions.","resolution":"Init should copy agents/*.md to .overstory/agent-defs/ in target project and set agents.baseDir to .overstory/agent-defs.","classification":"tactical","recorded_at":"2026-02-12T20:58:11.309Z","id":"mx-0d55fe"}
{"type":"decision","title":"Agent definition deployment: copy to .overstory/agent-defs/","rationale":"Agent defs should be git-tracked (not gitignored) so the project is self-contained. This follows the 'state location: in target repo' design principle. Init copies agents/*.md to .overstory/agent-defs/ and sets agents.baseDir accordingly.","classification":"tactical","recorded_at":"2026-02-12T20:58:14.425Z","id":"mx-a72fd8"}
{"type":"decision","title":"Wide swarm shape: maxConcurrent 5 to 25","rationale":"Target 1 coordinator → 4-5 leads → 4-5 builders each = 20-25 concurrent agents. Coordinator at depth 0 does strategic coordination only, leads at depth 1 handle spec-writing and builder management.","classification":"tactical","recorded_at":"2026-02-13T15:50:21.024Z","id":"mx-2934d8"}
{"type":"reference","name":"molecules-api-status","description":"molecules.ts is aspirational: expects bd mol create/step/list/status commands that don't exist. Real bd uses formula/cook/pour/wisp. Tests mock subprocess calls until API implemented.","classification":"tactical","recorded_at":"2026-02-13T16:28:48.858Z","id":"mx-96c861"}
{"type":"decision","title":"Migrate operational commands to SessionStore","rationale":"Replace fragile JSON file read/write/modify cycles with atomic SQLite operations via SessionStore. Eliminates race conditions from concurrent agent processes writing to sessions.json.","classification":"tactical","recorded_at":"2026-02-14T02:51:06.882Z","id":"mx-a843ee"}
{"type":"decision","title":"SessionStore replaces sessions.json","rationale":"Eliminates race conditions from concurrent JSON read-modify-write. SQLite WAL mode provides safe concurrent access from multiple agents.","classification":"tactical","recorded_at":"2026-02-14T03:08:45.357Z","id":"mx-65492d"}
{"type":"decision","title":"killAllTmuxSessions must be project-scoped","rationale":"During dogfooding, the global 'overstory-' prefix kill pattern in clean.ts destroyed a live swarm when bun test ran clean.test.ts. The function kills ALL overstory-prefixed tmux sessions regardless of which project they belong to. Either scope the kill to the current project via SessionStore lookup, or encode project identity into tmux session names.","classification":"tactical","recorded_at":"2026-02-14T04:14:18.929Z","id":"mx-93f612"}
{"type":"decision","title":"RunStore shares sessions.db with SessionStore","rationale":"Same Database instance creates both tables, avoiding a separate DB file for run tracking. Both stores use WAL mode and can be opened independently on the same file path.","classification":"tactical","recorded_at":"2026-02-14T04:32:52.291Z","id":"mx-c8a347"}
{"type":"failure","description":"overstory merge fails when builder branches contain out-of-scope commits (e.g. community files). The divergent branch base creates .beads/issues.jsonl conflicts that all resolution tiers fail on.","resolution":"Cherry-pick specific implementation commits onto a clean branch instead of merging the full branch. Spawn a cherry-pick lead with explicit commit SHAs.","classification":"tactical","recorded_at":"2026-02-14T06:41:27.622Z","tags":["merge","cherry-pick","workaround"],"id":"mx-b5cf1a"}
{"type":"failure","description":"SQLite migration of merge queue created chicken-and-egg problem: builder changed queue.ts to expect SQLite but left all consumers referencing JSON file path. The merge command itself was broken, blocking merging of the fix.","resolution":"All consumers must be updated in the same commit as the storage backend migration, or the migration must handle both formats during transition. Also: coordinator had to escalate to human to delete the stale runtime file.","classification":"tactical","recorded_at":"2026-02-16T15:59:04.798Z","id":"mx-61f2a2"}
{"type":"convention","content":"Phase 1 batch coordination: 10 issues across 3 initial leads with non-overlapping file areas. Required 4 replacement leads due to early exits. Total: 7 leads, 35 sessions, ~1 hour. Task group auto-close worked correctly. Lesson: prefer 1 lead per issue over batching N issues to 1 lead, since leads reliably complete only their primary task.","classification":"tactical","recorded_at":"2026-02-16T22:00:39.342Z","id":"mx-0dc049"}
{"type":"pattern","name":"merge-conflict-history-intelligence","description":"Parse mulch records for past conflict patterns (resolved/failed, tier, files), build history with tier skip logic (>=2 failures + 0 successes = skip), enrich AI prompts with past successful resolutions, query via fire-and-forget (empty history on failure). Integration: queryConflictHistory() in resolve() after clean-merge failure, skip check wraps each tier.","classification":"tactical","recorded_at":"2026-02-17T02:25:43.740Z","tags":["merge-conflict","learning"],"id":"mx-e09f5c"}
{"type":"failure","description":"Mulch JSONL files (.mulch/expertise/*.jsonl) cause merge conflicts when multiple agent branches append records. Branches forked before a merge that touches .mulch/ will conflict on re-merge.","resolution":"Mitigations: (1) instruct merge-fix builders to skip mulch record step, (2) fork fix branches from latest main so .mulch base is current, (3) future: implement append-only JSONL merge strategy (union lines instead of conflict).","classification":"tactical","recorded_at":"2026-02-17T02:28:38.680Z","id":"mx-69fdcb"}
